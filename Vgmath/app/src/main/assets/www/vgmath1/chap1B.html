<!DOCTYPE html> 
<html>
  <head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>第１章　関数（三角関数）</title>
	<script type="text/x-mathjax-config">
	 MathJax.Hub.Config({
	   tex2jax: { inlineMath: [['$','$'], ["\\(","\\)"]] } 
	 });
	</script>
	<script type="text/x-mathjax-config">
	 MathJax.Hub.Config({ TeX: { extensions: ["color.js"] }});
	</script>
	<script type="text/javascript" src="../MathJax/MathJax.js?config=TeX-AMS_HTML"></script>
	<link href="jquery.mobile-1.4.4.min.css" rel="stylesheet" type="text/css"/>
	<link href="vg.css" rel="stylesheet" type="text/css"/>
	<script src="jquery.js" type="text/javascript"></script>
	<script src="jquery.mobile-1.4.4.min.js" type="text/javascript"></script>
	<script src="rescalescreensankaku.js" type="text/javascript"></script>
	<script src="dragmanscreensankaku.js" type="text/javascript"></script>
	<script src="draggablepoint.js" type="text/javascript"></script>
	<script type="text/javascript">
	 function marume6(x) {
	   var xx=x*1000000;
	   xx=Math.round(xx);
	   xx/=1000000;
       if( x- xx == 0 ) {
		 return xx;
       } else {
		 return xx+"…";
       }
	 }
	 function marume4(x) {
	   x*=10000;
	   x=Math.round(x);
	   x/=10000;
       return x;
	 }
	 var Doukei=function(t,c) {
	   DraggablePoint.call(this,0,0,1,c); // 親クラスのコンストラクタを呼ぶ。
	   this.val=t;
	   this.inP=function(xx,yy) {
		 var t=Math.atan2(yy,xx);
		 while( t > this.val +Math.PI ) {
		   t -=2*Math.PI;
		 }
		 while( t < this.val -Math.PI ) {
		   t +=2*Math.PI;
		 }
		 if( Math.abs(t-this.val) < 0.1 ) {
		   return true;
		 } else {
		   return false;
		 }
	   };
	   this.setXY=function(xx,yy) {
		 // この動径棒の場合はドラッグする場所には意味がないので、shiftを戻す。
		 xx += this.shiftx;
		 yy += this.shifty;
		 this.val0=this.val;
		 this.val=Math.atan2(yy,xx);
		 // this.valの方は一般角なので、π以上の差がある時には2πを足したり引いたりして調節する。
		 while( this.val > this.val0+Math.PI ) {
		   this.val -= 2*Math.PI;
		 }
		 while( this.val < this.val0-Math.PI ) {
		   this.val += 2*Math.PI;
		 }
	   };
	   this.write=function(ct) {
		 ct.beginPath();
		 ct.strokeStyle=this.col;
		 ct.moveTo(0,0);
		 ct.lineTo(Math.cos(this.val),Math.sin(this.val));
		 ct.stroke();
		 ct.fillStyle="rgba(255,100,0,0.5)";
		 ct.beginPath();
		 ct.arc(0,0,0.1,0,2*Math.PI,true);
		 ct.fill();

		 var theta=this.val;
		 ct.fillStyle="rgba(180,180,255,0.5)";
		 ct.arc(Math.cos(theta),Math.sin(theta),0.1,0,2*Math.PI,true);
		 ct.fill();
	   };
	 };
	 var gs1,gs2,nowgs;
	 var DraggablePR=function(xx,yy,rr,c,A,H) {
	   DraggablePoint.call(this,xx,yy,rr,c); // 親クラスのコンストラクタを呼ぶ。
	   this.pA=A;
	   this.pH=H;
	   this.inP=function(xx,yy) {
		 if( this.canDrag ) { 
		   if( (xx-this.x)*(xx-this.pA.x) <0  &&  (yy-this.y)*(yy-this.pH.y) <0 ) {
			 return true;
		   } else {
			 return false;
		   }
		 } else {
		   return false;
		 }
	   };
	   this.setXY=function(xx,yy,x0,x1,y0,y1) {
		 var shiftx,shifty;
		 if( xx < x0+this.r ) {
		   shiftx=x0+this.r-this.x;
		   this.x=x0+this.r;
		 } else if( xx > x1-this.r ) {
		   shiftx=x1-this.r-this.x;
		   this.x=x1-this.r;
		 } else {
		   shiftx=xx-this.x;
		   this.x=xx;
		 }
		 if( yy< y0+this.r ) {
		   shifty=y0+this.r-this.y;
		   this.y=y0+this.r;
		 } else if( yy >y1-this.r ) {
		   shifty=y1-this.r-this.y;
		   this.y=y1-this.r;
		 } else {
		   shifty=yy-this.y;
		   this.y=yy;
		 }
		 // pRは直角三角形の直角頂点なので、他の２点が一緒に動く
		 this.pH.x=this.x;
		 this.pH.y += shifty;
		 this.pA.y=this.y;
		 this.pA.x += shiftx;
	   };
	   this.write=function(ct) {
		 ct.fillStyle=this.col;
		 ct.beginPath();
		 ct.moveTo(this.x,this.y);
		 ct.lineTo(this.pA.x,this.pA.y);
		 ct.lineTo(this.pH.x,this.pH.y);
		 ct.closePath();
		 ct.fill();
	   };
	 };
	 var DraggablePH=function(xx,yy,rr,c) {
	   DraggablePoint.call(this,xx,yy,rr,c); // 親クラスのコンストラクタを呼ぶ。
	   this.setXY=function(xx,yy,x0,x1,y0,y1) {
		 // pHは直角三角形の上の頂点なので、x座標は動かない。
		 if( yy< y0+this.r ) {
		   this.y=y0+this.r;
		 } else if( yy >y1-this.r ) {
		   this.y=y1-this.r;
		 } else {
		   this.y=yy;
		 };
	   };
	   this.write=function(ct) {
		 ct.fillStyle=this.col;
		 ct.beginPath();
		 ct.arc(this.x,this.y,this.r,0,2*Math.PI,false);
		 ct.fill();
		 ct.fillStyle="rgba(255,255,255,0.7)";
		 ct.beginPath();
		 ct.moveTo(this.x,this.y-this.r);
		 ct.lineTo(this.x+0.4*this.r,this.y-this.r*0.6);
		 ct.lineTo(this.x+0.1*this.r,this.y-this.r*0.6);
		 ct.lineTo(this.x+0.1*this.r,this.y+this.r*0.6);
		 ct.lineTo(this.x+0.4*this.r,this.y+this.r*0.6);
		 ct.lineTo(this.x,this.y+this.r);
		 ct.lineTo(this.x-0.4*this.r,this.y+this.r*0.6);
		 ct.lineTo(this.x-0.1*this.r,this.y+this.r*0.6);
		 ct.lineTo(this.x-0.1*this.r,this.y-this.r*0.6);
		 ct.lineTo(this.x-0.4*this.r,this.y-this.r*0.6);
		 
		 ct.fill();
	   };
	 };
	 var DraggablePA=function(xx,yy,rr,c) {
	   DraggablePoint.call(this,xx,yy,rr,c); // 親クラスのコンストラクタを呼ぶ。
	   this.setXY=function(xx,yy,x0,x1,y0,y1) {
		 // pAは直角三角形の底辺の直角でない方の頂点なので、y座標は動かない。
		 if( xx < x0+this.r ) {
		   this.x=x0+this.r;
		 } else if( xx > x1-this.r ) {
		   this.x=x1-this.r;
		 } else {
		   this.x=xx;
		 }
	   };
	   this.write=function(ct) {
		 ct.fillStyle=this.col;
		 ct.beginPath();
		 ct.arc(this.x,this.y,this.r,0,2*Math.PI,false);
		 ct.fill();
		 ct.fillStyle="rgba(200,200,255,0.8)";
		 ct.beginPath();
		 ct.moveTo(this.x-this.r,this.y);
		 ct.lineTo(this.x-this.r*0.6,this.y+0.4*this.r);
		 ct.lineTo(this.x-this.r*0.6,this.y+0.1*this.r);
		 ct.lineTo(this.x+this.r*0.6,this.y+0.1*this.r);
		 ct.lineTo(this.x+this.r*0.6,this.y+0.4*this.r);
		 ct.lineTo(this.x+this.r,this.y);
		 ct.lineTo(this.x+this.r*0.6,this.y-0.4*this.r);
		 ct.lineTo(this.x+this.r*0.6,this.y-0.1*this.r);
		 ct.lineTo(this.x-this.r*0.6,this.y-0.1*this.r);
		 ct.lineTo(this.x-this.r*0.6,this.y-0.4*this.r);
		 
		 ct.fill();
	   };
	 };
	 // 親クラスタのプロトタイプを継承する。
	 Doukei.prototype=Object.create(DraggablePoint.prototype);
	 Doukei.prototype.constructor=Doukei;
	 DraggablePR.prototype=Object.create(DraggablePoint.prototype);
	 DraggablePR.prototype.constructor=DraggablePR;
	 DraggablePA.prototype=Object.create(DraggablePoint.prototype);
	 DraggablePA.prototype.constructor=DraggablePA;
	 DraggablePH.prototype=Object.create(DraggablePoint.prototype);
	 DraggablePH.prototype.constructor=DraggablePH;
	 var DraggablePH1=function(xx,yy,rr,c) {
	   DraggablePH.call(this,xx,yy,rr,c); // 親クラスのコンストラクタを呼ぶ。
	   this.setXY=function(xx,yy,x0,x1,y0,y1) {
		 // pHは直角三角形の上の頂点なので、x座標は動かない。
		 var lenlen=1-(yy-nowgs.pA.y)*(yy-nowgs.pA.y);
		 // このlenlenが負になる領域には動かせない。
		 if( lenlen < 0 ) {
		   return;
		 }
		 if( yy< y0+this.r ) {
		   this.y=y0+this.r;
		 } else if( yy >y1-this.r ) {
		   this.y=y1-this.r;
		 } else {
		   this.y=yy;
		 }
		 if( nowgs.pA.x>nowgs.pR.x ) {
		   nowgs.pA.x=nowgs.pR.x + Math.sqrt(lenlen);
		 } else {
		   nowgs.pA.x=nowgs.pR.x - Math.sqrt(lenlen);
		 }
	   };
	 };
	 DraggablePH1.prototype=Object.create(DraggablePH.prototype);
	 DraggablePH1.prototype.constructor=DraggablePH1;
	 var DraggablePA1=function(xx,yy,rr,c) {
	   DraggablePA.call(this,xx,yy,rr,c); // 親クラスのコンストラクタを呼ぶ。
	   this.setXY=function(xx,yy,x0,x1,y0,y1) {
		 // pAは直角三角形の底辺の直角でない方の頂点なので、y座標は動かない。
		 var lenlen=1-(xx-nowgs.pH.x)*(xx-nowgs.pH.x);
		 // このlenlenが負になる領域には動かせない。
		 if( lenlen < 0 ) {
		   return;
		 }
		 if( xx< x0+this.r ) {
		   this.x=x0+this.r;
		 } else if( xx >x1-this.r ) {
		   this.x=x1-this.r;
		 } else {
		   this.x=xx;
		 }
		 if( nowgs.pH.y>nowgs.pR.y ) {
		   nowgs.pH.y=nowgs.pR.y + Math.sqrt(lenlen);
		 } else {
		   nowgs.pH.y=nowgs.pR.y - Math.sqrt(lenlen);
		 }
	   };
	 };
	 DraggablePA1.prototype=Object.create(DraggablePA.prototype);
	 DraggablePA1.prototype.constructor=DraggablePA1;


	 function writeSincostan(gs,ct) {
	   var teihen=(gs.pR.x-gs.pA.x);
	   var takasa=(gs.pH.y-gs.pR.y);
	   var shahen=Math.sqrt(teihen*teihen+takasa*takasa);
	   $(".teihen").html("隣辺="+marume6(teihen));
	   $(".takasa").html("対辺="+marume6(takasa));
	   $(".shahen").html("斜辺="+marume6(shahen));
	   $(".sin").html(marume6(takasa/shahen));
	   $(".cos").html(marume6(teihen/shahen));
	   $(".tan").html(marume6(takasa/teihen));
	   var theta=Math.atan2(takasa,teihen);
	   $(".theta").html("θ="+marume6(theta)+"ラジアン（"+marume6(theta*180/Math.PI)+"度）");
	   ct.strokeStyle="rgb(0,0,0)";
	   ct.beginPath();
	   if(theta >0 ) {
		 ct.arc(gs.pA.x,gs.pA.y,0.8,0,theta);
	   } else {
		 ct.arc(gs.pA.x,gs.pA.y,0.8,theta,0);
	   }
	   ct.stroke();
	 }
	 $(document).delegate('#page1','pageinit',function(e) {
       gs1=new DragmanScreen("canvas0",6,6,0.7);
       gs1.setLeft(-1);
       gs1.setBottom(-1);
       gs1.gobackOriginalSize();
       gs1.writeContents=function() {
		 graphWrite(gs1);
       }; 
	   gs1.pH=new DraggablePH(4,3,0.4,"rgba(180,180,255,0.5)");
	   gs1.pA=new DraggablePA(0,0,0.4,"rgba(213,123,53,0.5)");
	   gs1.pR=new DraggablePR(4,0,0.4,"rgba(200,200,200,0.5)",gs1.pA,gs1.pH);
	   gs1.pushDragObjList(gs1.pH);
	   gs1.pushDragObjList(gs1.pA);
	   gs1.pushDragObjList(gs1.pR);
	   nowgs=gs1;
	 });
	 $(document).delegate('#page1','pageshow',function(e) {
	   nowgs=gs1;
       graphWrite(gs1);
	 });
	 $(document).delegate('#page2','pageinit',function(e) {
       gs2=new DragmanScreen("canvas1",6,6,0.7);
       gs2.setLeft(-1);
       gs2.setBottom(-1);
       gs2.gobackOriginalSize();
       gs2.writeContents=function() {
		 graphWrite(gs2);
       }; 
	   gs2.pH=new DraggablePH(4,3,0.4,"rgba(180,180,255,0.5)");
	   gs2.pA=new DraggablePA(0,0,0.4,"rgba(213,123,53,0.5)");
	   gs2.pR=new DraggablePR(4,0,0.4,"rgba(200,200,200,0.5)",gs2.pA,gs2.pH);
	   gs2.pushDragObjList(gs2.pH);
	   gs2.pushDragObjList(gs2.pA);
	   gs2.pushDragObjList(gs2.pR);
	   nowgs=gs2;
	 });
	 $(document).delegate('#page2','pageshow',function(e) {
	   nowgs=gs2;
       graphWrite(gs2);
	 });
	 var gs2;
	 $(document).delegate('#page3','pageinit',function(e) {
	   costhetaimage=new Image();
	   costhetaimage.src="costheta.png";
	   sinthetaimage=new Image();
	   sinthetaimage.src="sintheta.png";

       gs3=new DragmanScreen("canvas3",2,2,0.7);
       gs3.setLeft(-0.2);
       gs3.setBottom(-0.2);
       gs3.gobackOriginalSize();
       gs3.writeContents=function() {
		 graphWrite1(gs3);
       }; 
	   gs3.pH=new DraggablePH1(0.8,0.6,0.1,"rgba(180,180,255,0.5)");
	   gs3.pA=new DraggablePA1(0,0,0.1,"rgba(255,100,0,0.5)");
	   gs3.pR=new DraggablePR(0.8,0,0.1,"rgba(200,200,200,0.5)",gs3.pA,gs3.pH);
	   gs3.pushDragObjList(gs3.pH);
	   gs3.pushDragObjList(gs3.pA);
	   gs3.pushDragObjList(gs3.pR);
	   nowgs=gs3;
	 });
	 var gs3;
	 $(document).delegate('#page3','pageshow',function(e) {
	   nowgs=gs3;
       graphWrite1(gs3);
	 });
	 var costhetaimage;
	 var sinthetaimage;
	 $(document).delegate('#page4_0','pageinit',function(e) {
	   sinthetaimage=new Image();
	   sinthetaimage.src="sintheta.png";
       gs4_0=new DragmanScreen("canvas4_0",9.2,2.6,0.85);
	   gs4_0.setLeft(-1.3);
	   gs4_0.setBottom(-1.3);
	   gs4_0.gobackOriginalSize();
	   gs4_0.writeContents=function() {
		 allSinWrite(gs4_0);
	   };
	   gs4_0.theta=0.25*Math.PI;
	   gs4_0.orgx=3.0;
	   gs4_0.doukei=new Doukei(0.25*Math.PI,"rgb(100,100,0)");
	   gs4_0.pushDragObjList(gs4_0.doukei);
	   nowgs=gs4_0;
	 });
	 $(document).delegate('#page4_0','pageshow',function(e) {
	   nowgs=gs4_0;
       allSinWrite(gs4_0);
	 });
	 $(document).delegate('#page4','pageinit',function(e) {
	   costhetaimage=new Image();
	   costhetaimage.src="costheta.png";
	   sinthetaimage=new Image();
	   sinthetaimage.src="sintheta.png";
       gs4=new DragmanScreen("canvas4",6,6,0.75);
	   gs4.setLeft(-1.3);
	   gs4.setBottom(-1.3);
	   gs4.gobackOriginalSize();
	   gs4.writeContents=function() {
		 unitCircleWrite(gs4);
	   };
	   gs4.doukei=new Doukei(0.25*Math.PI,"rgb(100,100,0)");
	   gs4.pushDragObjList(gs4.doukei);
	   nowgs=gs4;
	 });
	 $(document).delegate('#page4','pageshow',function(e) {
	   nowgs=gs4;
       unitCircleWrite(gs4);
	 });
	 var sinsthetaimage2;
	 var costhetaimage2;
	 $(document).delegate('#page5','pageinit',function(e) {
	   costhetaimage=new Image();
	   costhetaimage.src="costheta.png";
	   sinthetaimage=new Image();
	   sinthetaimage.src="sintheta.png";
	   costhetaimage2=new Image();
	   costhetaimage2.src="costheta+pi.png";
	   sinthetaimage2=new Image();
	   sinthetaimage2.src="sintheta+pi.png";
       gs5=new DragmanScreen("canvas5",7.6,7.6,0.75);
	   gs5.setLeft(-1.3);
	   gs5.setBottom(-1.3);
	   gs5.gobackOriginalSize();
	   gs5.writeContents=function() {
		 unitCircleWrite2(gs5,Math.PI);
	   };
	   gs5.doukei=new Doukei(0.25*Math.PI,"rgb(100,100,0)");
	   gs5.pushDragObjList(gs5.doukei);
	   nowgs=gs5;
	 });
	 $(document).delegate('#page6','pageinit',function(e) {
	   costhetaimage=new Image();
	   costhetaimage.src="costheta.png";
	   sinthetaimage=new Image();
	   sinthetaimage.src="sintheta.png";
	   costhetaimage2=new Image();
	   costhetaimage2.src="costheta+halfpi.png";
	   sinthetaimage2=new Image();
	   sinthetaimage2.src="sintheta+halfpi.png";
       gs6=new DragmanScreen("canvas6",7.6,7.6,0.75);
	   gs6.setLeft(-1.3);
	   gs6.setBottom(-1.3);
	   gs6.gobackOriginalSize();
	   gs6.writeContents=function() {
		 unitCircleWrite2(gs6,0.5*Math.PI);
	   };
	   gs6.doukei=new Doukei(0.25*Math.PI,"rgb(100,100,0)");
	   gs6.pushDragObjList(gs6.doukei);
	   nowgs=gs6;
	 });
	 $(document).delegate('#page5','pageshow',function(e) {
	   nowgs=gs5;
       unitCircleWrite2(gs5,Math.PI);
	 });
	 $(document).delegate('#page6','pageshow',function(e) {
	   nowgs=gs6;
       unitCircleWrite2(gs6,0.5*Math.PI);
	 });
	 function allSinWrite(gs) {
	   var ct=gs.ctx;
	   gs.setScale();
       gs.clearALL();
	   ct.fillStyle="rgb(235,255,255)";
	   ct.fillRect(gs.leftwx,gs.bottomy,2.6,gs.h);
	   ct.fillStyle="rgb(255,255,235)";
	   ct.fillRect(1.4,gs.bottomy,gs.w,gs.h);
	   ct.beginPath();
	   ct.strokeStyle="rgb(200,200,200)";
	   ct.arc(0,0,1,0,2*Math.PI,false);
	   ct.stroke();
	   ct.strokeStyle="rgb(0,0,0)";
	   ct.fillStyle="rgb(0,0,0)";
	   writeTatejiku(ct,1.3,-1.3,0);
	   writeYokojiku(ct,1.3,-1.3,0);
	   writeYokojiku(ct,7.8,1.4,0);

	   var th=gs.doukei.val;
	   $(".theta").html("θ="+marume4(th)+"ラジアン（"+marume4(th*180/Math.PI)+"度）");

	   var sinth=Math.sin(th);
	   var costh=Math.cos(th);
	   // thが表示できる範囲にあるかをチェック。
	   // gs.orgx==3 の時は-Math.PIから3*Math.PIまでを表示している。
	   // -Math.PI-2*(gs.orgx-3)から-2*(gs.orgx-3)+3*Math.PIまでを表示する。
	   if( th < -2*(gs.orgx-3)-Math.PI ) {
		 gs.orgx = 3-0.5*(th +Math.PI);
	   }
	   if( th > -2*(gs.orgx-3)+3*Math.PI ) {
		 gs.orgx = 3-0.5*(th-3*Math.PI);
	   }

	   ct.strokeStyle="rgb(0,0,200)";
	   ct.fillStyle="rgb(0,0,200)";
	   if( gs.orgx >= 1.4 && gs.orgx <= 7.8 ) {
		 writeTatejiku(ct,1.3,-1.3,gs.orgx);
	   }
	   ct.beginPath();
	   var th1=-2*(gs.orgx-3)-Math.PI;
	   ct.moveTo(3.0-0.5*Math.PI,Math.sin(th1));
	   var x;
	   for(x=th1+Math.PI/50; x<=th1+4*Math.PI ; x+=Math.PI/50 ) {
		 ct.lineTo(gs.orgx+0.5*x,Math.sin(x));
	   }
	   ct.lineTo(gs.orgx+0.5*x,Math.sin(x));
	   ct.stroke();
	   
	   ct.strokeStyle="rgba(0,0,200,0.5)";
	   ct.beginPath();
	   ct.moveTo(costh,sinth);
	   ct.lineTo(gs.orgx+0.5*th,sinth);
	   ct.stroke();
	   
	   ct.beginPath();
	   ct.strokeStyle="rgba(100,100,0,0.3)";
	   ct.moveTo(0.8,0);
	   if( th > 0 ) {
		 for( th1=0; th1 < th ; th1 += 0.05 ) {
		   ct.lineTo((0.8-th1*0.01)*Math.cos(th1),(0.8-th1*0.01)*Math.sin(th1));
		 }
	   } else {
		 for( th1=0; th1 > th ; th1 -= 0.05 ) {
		   ct.lineTo((0.8+th1*0.01)*Math.cos(th1),(0.8+th1*0.01)*Math.sin(th1));
		 }
	   }
	   ct.stroke();
	   
	   
	   gs.doukei.write(ct);
	   
	   gs.saveScale();
	   var x1=gs.fromCxtoMx(gs.orgx+0.5*th-0.1);
	   var y1=gs.fromCytoMy(sinth);
	   var x2=gs.fromCxtoMx(gs.orgx+0.5*th+0.1);
	   var y2=gs.fromCytoMy(0);
	   if( y2>y1) {
		 ct.drawImage(sinthetaimage,x1,y1,x2-x1,y2-y1);
	   } else {
		 ct.scale(1,-1);
		 ct.drawImage(sinthetaimage,x1,-y1,x2-x1,y1-y2);
	   }
	   gs.restoreScale();
	 }
	 function unitCircleWrite(gs) {
	   var ct=gs.ctx;
	   gs.setScale();
	   gs.clearALL();
	   ct.fillStyle="rgb(235,255,255)";
	   ct.fillRect(gs.leftwx,gs.bottomy,2.6,2.6);
	   
	   ct.fillStyle="rgb(255,255,235)";
	   ct.fillRect(1.4,gs.bottomy,3.2,2.6);
	   ct.fillRect(gs.leftwx,1.4,2.6,3.2);


	   ct.beginPath();
	   ct.strokeStyle="rgb(200,200,200)";
	   ct.arc(0,0,1,0,2*Math.PI,false);
	   ct.stroke();
	   ct.strokeStyle="rgb(0,0,0)";
	   ct.fillStyle="rgb(0,0,0)";
	   writeTatejiku(ct,1.3,-1.3,0);
	   writeTatejiku(ct,4.6,1.4,0);
	   writeYokojiku(ct,1.3,-1.3,0);
	   writeYokojiku(ct,4.6,1.4,0);
	   ct.strokeStyle="rgb(200,0,0)";
	   ct.fillStyle="rgb(200,0,0)";
	   ct.beginPath();
	   ct.moveTo(-1,3.0-0.5*Math.PI);
	   var x;
	   for(x=-Math.PI+Math.PI/50; x<=Math.PI ; x+=Math.PI/50 ) {
		 ct.lineTo(Math.cos(x),3.0+0.5*x);
	   }
	   ct.lineTo(Math.cos(x),3.0+0.5*x);
	   ct.stroke();
	   writeYokojiku(ct,1.3,-1.3,3.0);
	   ct.strokeStyle="rgb(0,0,200)";
	   ct.fillStyle="rgb(0,0,200)";
	   writeTatejiku(ct,1.3,-1.3,3.0);
	   ct.beginPath();
	   ct.moveTo(3.0-0.5*Math.PI,0);
	   var x;
	   for(x=-Math.PI+Math.PI/50; x<=Math.PI ; x+=Math.PI/50 ) {
		 ct.lineTo(3.0+0.5*x,Math.sin(x));
	   }
	   ct.lineTo(3.0+0.5*x,Math.sin(x));
	   ct.stroke();
	   var th=gs.doukei.val;
	   while( th > Math.PI ) {
		 th -= 2*Math.PI;
	   }
	   while( th < -Math.PI ) {
		 th += 2*Math.PI;
	   }
	   var sinth=Math.sin(th);
	   var costh=Math.cos(th);
	   ct.strokeStyle="rgba(0,0,200,0.5)";
	   ct.beginPath();
	   ct.moveTo(costh,sinth);
	   ct.lineTo(3.0+0.5*th,sinth);
	   ct.stroke();
	   ct.strokeStyle="rgba(200,0,0,0.5)";
	   ct.beginPath();
	   ct.moveTo(costh,sinth);
	   ct.lineTo(costh,3.0+0.5*th);
	   ct.stroke();
	   gs.doukei.write(ct);

	   gs.saveScale();
	   var x1=gs.fromCxtoMx(0);
	   var y1=gs.fromCytoMy(3.0+0.5*th-0.2);
	   var x2=gs.fromCxtoMx(costh);
	   var y2=gs.fromCytoMy(3.0+0.5*th);
	   if( x2 > x1 ) {
		 ct.drawImage(costhetaimage,x1,y2,x2-x1,y1-y2);
	   } else {
		 ct.scale(-1,1);
		 ct.drawImage(costhetaimage,-x1,y2,x1-x2,y1-y2);
	   }
	   gs.restoreScale();
	   gs.saveScale();
	   x1=gs.fromCxtoMx(3.0+0.5*th-0.1);
	   y1=gs.fromCytoMy(sinth);
	   x2=gs.fromCxtoMx(3.0+0.5*th+0.1);
	   y2=gs.fromCytoMy(0);
	   if( y2>y1) {
		 ct.drawImage(sinthetaimage,x1,y1,x2-x1,y2-y1);
	   } else {
		 ct.scale(1,-1);
		 ct.drawImage(sinthetaimage,x1,-y1,x2-x1,y1-y2);
	   }
	   gs.restoreScale();
	 }
	 function unitCircleWrite2(gs,deltheta) {
	   var ct=gs.ctx;
	   gs.setScale();
	   gs.clearALL();
	   ct.fillStyle="rgb(235,255,255)";
	   ct.fillRect(gs.leftwx,gs.bottomy,2.6,2.6);
	   ct.fillStyle="rgb(255,255,235)";
	   ct.fillRect(1.4,gs.bottomy,4.8,2.6);
	   ct.fillRect(gs.leftwx,1.4,2.6,4.8);
	   ct.beginPath();
	   ct.strokeStyle="rgb(200,200,200)";
	   ct.arc(0,0,1,0,2*Math.PI,false);
	   ct.stroke();
	   ct.strokeStyle="rgb(0,0,0)";
	   ct.fillStyle="rgb(0,0,0)";
	   writeTatejiku(ct,1.3,-1.3,0);
	   writeTatejiku(ct,6.2,1.4,0);
	   writeYokojiku(ct,1.3,-1.3,0);
	   writeYokojiku(ct,6.2,1.4,0);
	   ct.strokeStyle="rgb(200,0,0)";
	   ct.fillStyle="rgb(200,0,0)";
	   ct.beginPath();
	   ct.moveTo(-1,3.0-0.5*Math.PI);
	   var x;
	   for(x=-Math.PI+Math.PI/50; x<=2*Math.PI ; x+=Math.PI/50 ) {
		 ct.lineTo(Math.cos(x),3.0+0.5*x);
	   }
	   ct.lineTo(Math.cos(x),3.0+0.5*x);
	   ct.stroke();
	   writeYokojiku(ct,1.3,-1.3,3.0);
	   ct.strokeStyle="rgb(187,63,133)";
	   ct.fillStyle="rgb(187,63,133)";
	   writeTatejiku(ct,1.3,-1.3,3.0);
	   ct.beginPath();
	   ct.moveTo(3.0-0.5*Math.PI,0);
	   var x;
	   for(x=-Math.PI+Math.PI/50; x<=2*Math.PI ; x+=Math.PI/50 ) {
		 ct.lineTo(3.0+0.5*x,Math.sin(x));
	   }
	   ct.lineTo(3.0+0.5*x,Math.sin(x));
	   ct.stroke();
	   var th=gs.doukei.val;
	   while( th > Math.PI ) {
		 th -= 2*Math.PI;
	   }
	   while( th < -Math.PI ) {
		 th += 2*Math.PI;
	   }
	   var sinth=Math.sin(th);
	   var costh=Math.cos(th);
	   ct.strokeStyle="rgba(187,63,133,0.3)";
	   ct.beginPath();
	   ct.moveTo(costh,sinth);
	   ct.lineTo(3.0+0.5*th,sinth);
	   ct.stroke();
	   ct.strokeStyle="rgba(200,0,0,0.3)";
	   ct.beginPath();
	   ct.moveTo(costh,sinth);
	   ct.lineTo(costh,3.0+0.5*th);
	   ct.stroke();
	   gs.doukei.write(ct);

	   gs.saveScale();
	   var x1=gs.fromCxtoMx(0);
	   var y1=gs.fromCytoMy(3.0+0.5*th-0.2);
	   var x2=gs.fromCxtoMx(costh);
	   var y2=gs.fromCytoMy(3.0+0.5*th);
	   if( x2 > x1 ) {
		 ct.drawImage(costhetaimage,x1,y2,x2-x1,y1-y2);
	   } else {
		 ct.scale(-1,1);
		 ct.drawImage(costhetaimage,-x1,y2,x1-x2,y1-y2);
	   }
	   gs.restoreScale();

	   gs.saveScale();
	   x1=gs.fromCxtoMx(3.0+0.5*th-0.1);
	   y1=gs.fromCytoMy(sinth);
	   x2=gs.fromCxtoMx(3.0+0.5*th+0.1);
	   y2=gs.fromCytoMy(0);
	   if( y2>y1) {
		 ct.drawImage(sinthetaimage,x1,y1,x2-x1,y2-y1);
	   } else {
		 ct.scale(1,-1);
		 ct.drawImage(sinthetaimage,x1,-y1,x2-x1,y1-y2);
	   }
	   gs.restoreScale();


	   th += +deltheta;
	   var sinth=Math.sin(th);
	   var costh=Math.cos(th);
	   ct.strokeStyle="rgba(200,200,0,0.3)";
	   ct.beginPath();
	   ct.moveTo(0,0);
	   ct.lineTo(costh,sinth);
	   ct.stroke();

	   ct.strokeStyle="rgba(187,63,133,0.5)";
	   ct.beginPath();
	   ct.moveTo(costh,sinth);
	   ct.lineTo(3.0+0.5*th,sinth);
	   ct.stroke();
	   ct.strokeStyle="rgba(200,0,0,0.5)";
	   ct.beginPath();
	   ct.moveTo(costh,sinth);
	   ct.lineTo(costh,3.0+0.5*th);
	   ct.stroke();

	   gs.saveScale();
	   var x1=gs.fromCxtoMx(0);
	   var y1=gs.fromCytoMy(3.0+0.5*th-0.2);
	   var x2=gs.fromCxtoMx(costh);
	   var y2=gs.fromCytoMy(3.0+0.5*th);
	   if( x2 > x1 ) {
		 ct.drawImage(costhetaimage2,x1,y2,x2-x1,y1-y2);
	   } else {
		 ct.scale(-1,1);
		 ct.drawImage(costhetaimage2,-x1,y2,x1-x2,y1-y2);
	   }
	   gs.restoreScale();
	   gs.saveScale();
	   x1=gs.fromCxtoMx(3.0+0.5*th-0.1);
	   y1=gs.fromCytoMy(sinth);
	   x2=gs.fromCxtoMx(3.0+0.5*th+0.1);
	   y2=gs.fromCytoMy(0);
	   if( y2>y1) {
		 ct.drawImage(sinthetaimage2,x1,y1,x2-x1,y2-y1);
	   } else {
		 ct.scale(1,-1);
		 ct.drawImage(sinthetaimage2,x1,-y1,x2-x1,y1-y2);
	   }
	   gs.restoreScale();
	   
	 }

	 function writeYokojiku(ct,x1,x2,y1) {
	   ct.beginPath();
	   ct.moveTo(x1,y1);
	   ct.lineTo(x1-0.2,y1+0.1);
	   ct.lineTo(x1-0.2,y1-0.1);
	   ct.closePath();
	   ct.fill();
	   ct.beginPath();
	   ct.moveTo(x1-0.1,y1);
	   ct.lineTo(x2,y1);
	   ct.stroke();
	 }
	 function writeTatejiku(ct,y1,y2,x1) {
	   ct.beginPath();
	   ct.moveTo(x1,y1);
	   ct.lineTo(x1+0.1,y1-0.2);
	   ct.lineTo(x1-0.1,y1-0.2);
	   ct.closePath();
	   ct.fill();
	   ct.beginPath();
	   ct.moveTo(x1,y2,0);
	   ct.lineTo(x1,y1-0.1);
	   ct.stroke();
	 }
	 function graphWrite(gs) {
	   var ct=gs.ctx;
	   gs.setScale();
	   gs.clearALL();
	   ct.fillStyle="rgb(235,255,255)";
	   ct.beginPath();
	   ct.fillRect(gs.leftwx,gs.bottomy,gs.w,gs.h);
	   

	   ct.beginPath();
	   ct.strokeStyle="rgb(213,123,56)";
	   ct.moveTo(gs.pR.x,gs.pR.y);
	   ct.lineTo(gs.pA.x,gs.pA.y);
	   ct.stroke();
	   if( gs.pA.x > gs.pH.x ) {
		 ct.strokeStyle="rgba(213,123,56,0.5)";
		 ct.moveTo(gs.pR.x,gs.pR.y);
		 ct.lineTo(gs.w,gs.pR.y);
		 ct.stroke();
	   }
	   ct.beginPath();
	   ct.strokeStyle="rgb(187,63,133)";
	   ct.moveTo(gs.pR.x,gs.pR.y);
	   ct.lineTo(gs.pH.x,gs.pH.y);
	   ct.stroke();
	   ct.beginPath();
	   ct.strokeStyle="rgb(100,100,0)";
	   ct.moveTo(gs.pH.x,gs.pH.y);
	   ct.lineTo(gs.pA.x,gs.pA.y);
	   ct.stroke();
	   

	   gs.pR.write(ct);
	   gs.pH.write(ct);
	   gs.pA.write(ct);
	   writeSincostan(gs,ct);
	 }
	 function graphWrite1(gs) {
	   var ct=gs.ctx;
	   gs.setScale();
	   gs.clearALL();
	   ct.fillStyle="rgb(235,255,255)";
	   ct.beginPath();
	   ct.fillRect(gs.leftwx,gs.bottomy,gs.w,gs.h);

	   var teihen=(gs.pR.x-gs.pA.x);
	   var takasa=(gs.pH.y-gs.pR.y);
	   var theta=Math.atan2(takasa,teihen);

	   $(".sin").html(marume6(takasa));
	   $(".cos").html(marume6(teihen));
	   var theta=Math.atan2(takasa,teihen);
	   $(".theta").html("θ="+marume6(theta)+"ラジアン（"+marume6(theta*180/Math.PI)+"度）");
	   gs.saveScale();
	   var x1=gs.fromCxtoMx(gs.pA.x);
	   var y1=gs.fromCytoMy(gs.pA.y-0.2);
	   var x2=gs.fromCxtoMx(gs.pR.x);
	   var y2=gs.fromCytoMy(gs.pR.y);
	   if( x2 > x1 ) {
		 ct.drawImage(costhetaimage,x1,y2,x2-x1,y1-y2);
	   } else {
		 ct.scale(-1,1);
		 ct.drawImage(costhetaimage,-x1,y2,x1-x2,y1-y2);
	   }
	   gs.restoreScale();
	   gs.saveScale();
	   x1=gs.fromCxtoMx(gs.pH.x-0.1);
	   y1=gs.fromCytoMy(gs.pH.y);
	   x2=gs.fromCxtoMx(gs.pH.x+0.1);
	   y2=gs.fromCytoMy(gs.pR.y);
	   if( y2>y1) {
		 ct.drawImage(sinthetaimage,x1,y1,x2-x1,y2-y1);
	   } else {
		 ct.scale(1,-1);
		 ct.drawImage(sinthetaimage,x1,-y1,x2-x1,y1-y2);
	   }
	   gs.restoreScale();
	   

	   ct.beginPath();
	   ct.strokeStyle="rgb(212,123,56)";
	   ct.moveTo(gs.pR.x,gs.pR.y);
	   ct.lineTo(gs.pA.x,gs.pA.y);
	   ct.stroke();
	   if( gs.pA.x > gs.pH.x ) {
		 ct.strokeStyle="rgba(213,123,56,0.5)";
		 ct.moveTo(gs.pR.x,gs.pR.y);
		 ct.lineTo(gs.w,gs.pR.y);
		 ct.stroke();
	   }
	   ct.beginPath();
	   ct.strokeStyle="rgb(187,63,133)";
	   ct.moveTo(gs.pR.x,gs.pR.y);
	   ct.lineTo(gs.pH.x,gs.pH.y);
	   ct.stroke();
	   ct.beginPath();
	   ct.strokeStyle="rgb(100,100,0)";
	   ct.moveTo(gs.pH.x,gs.pH.y);
	   ct.lineTo(gs.pA.x,gs.pA.y);
	   ct.stroke();
	   
	   gs.pR.write(ct);
	   gs.pH.write(ct);
	   gs.pA.write(ct);
	   ct.strokeStyle="rgb(0,0,0)";
	   ct.beginPath();
	   if(theta >0 ) {
		 ct.arc(gs.pA.x,gs.pA.y,0.2,0,theta);
	   } else {
		 ct.arc(gs.pA.x,gs.pA.y,0.2,theta,0);
	   }
	   ct.stroke();
	 }
	</script>
  </head>
  <body>
	<div data-role="page" id="page1">
	  <div data-role="header">
		<h1>三角形の辺の比による三角関数の定義</h1>
	  </div>
	  <div data-role="content">
		<p>　三角関数というのは「角度→直角三角形の辺の比」という関数としてまず定義される。つまり、「直角三角形の角度を一つ決めると、辺の比が決まる」という関係が「三角関数」である。理工学では、角度は「度」ではなく一周を$2\pi$とする角度がよく使われることが多い<span class="footnote">なぜか、というのはこの後三角関数の性質を考えていくなかで理解できるはずである。</span>。</p>
		<p>この角度の単位は「rad」と書いて「ラジアン」である。</p>
		<img src="radian.png" class="floatnone" width="75%">
		<p>　一周を2πラジアンとすると何が都合がいいかというと、半径r、頂角θの扇形の弧の長さが rθとなり、計算が楽になる（円は頂角2πの扇形と考えれば、その弧すなわち円周は2πrになる）。特に運動を考えているときは物体の移動する距離（長さ）の計算ができる限り簡単な方がよいので、以後も角度はラジアンを使う。</p>

		<p>　直角三角形の３辺を<span class="rinpen">隣辺</span>、<span class="taihen">対辺</span>、<span class="ki">斜辺</span>と下の図のように名付ける。</p>
		<img src="chokakusankakukei.png" width="35%">

		<p>　この三辺の比は、3×2=6通りの組み合わせがある。それぞれを、</p>
		<div><table cellpadding="2" cellspacing="0"><tbody><tr><td>sinθ=</td><td align="center" nowrap="nowrap"><span class="taihen">対辺</span><hr noshade="noshade" size="1"><span class="ki">斜辺</span></td><td>　　　</td><td>cosθ=</td><td align="center" nowrap="nowrap"><span class="rinpen">隣辺</span><hr noshade="noshade" size="1"><span class="ki">斜辺</span></td><td>　　　</td><td>tanθ=</td><td align="center" nowrap="nowrap"><span class="taihen">対辺</span><hr noshade="noshade" size="1"><span class="rinpen">隣辺</span></td><td></td></tr>
		  <tr><td>　</td></tr>
		  <tr><td>cosecθ=</td><td align="center" nowrap="nowrap"><span class="ki">斜辺</span><hr noshade="noshade" size="1"><span class="taihen">対辺</span></td><td>　　　</td><td>secθ=</td><td align="center" nowrap="nowrap"><span class="ki">斜辺</span><hr noshade="noshade" size="1"><span class="rinpen">隣辺</span></td><td>　　　</td><td>cotθ=</td><td align="center" nowrap="nowrap"><span class="rinpen">隣辺</span><hr noshade="noshade" size="1"><span class="taihen">対辺</span></td><td></td></tr></tbody></table></div>
		<p>と名付ける<span class="footnote">cosecは長いので、cscと略す場合もある。</span>。</p>

		<p>　上の段にある三つが一番よく使われるもので、下の段の三つは対応する上の段の逆数$\left({1\over \sin \theta}={\rm cosec}\,\theta, {1\over \cos \theta}=\sec\theta, {1\over \tan\theta}=\cot\theta\right)$になっている<span class="footnote">ややこしいことに、「サイン」の逆数が「<span class="aka">コ}セカント」で、「<span class="aka">コ}サイン」の逆数が「セカント」、と「コ」のつくのが入れ替わる。</span>。だから、下の段三つは使わないで済ませることもできる（以下でも上三つの$\sin,\cos,\tan$を主に考えていく）。</p>
		  <div class="setsumei">　以下の図の直角三角形はドラッグして動かすことができ、直角以外の頂点を動かすことで変形できる（ただし、天辺の頂点は上下にしか動かないし、底辺のうち直角でない方の点は左右にしか動かない）。点を動かしながら、それぞれの辺の比（sin,cos,tan）がどういう量かを実感しよう。</div>

		  <div align="center"><canvas id="canvas0" width=200 height=200 style="-ms-touch-action:none;"></canvas></div>
		  <div>	
			<div align="center"><span class="rinpen"><span class="teihen"></span></span></div>
			<br>
			<div align="center" class="takasa" id="takasa"></div>
			<br>
			<div align="center" class="shahen" id="shahen"></div>
			<br><div align="center" class="theta"></div>
		  </div>
		  <br>
		  <div><table cellpadding="2" cellspacing="0"><tbody><tr><td>sinθ=</td><td align="center" nowrap="nowrap"><span class="taihen"><span class="takasa"></span></span><hr noshade="noshade" size="1"><span class="ki"><span class="shahen"></span></span></td><td>=<span class="sin"></span></td></tr></tbody></table></div>
		  <br>
		  <div><table cellpadding="2" cellspacing="0"><tbody><tr><td>cosθ=</td><td align="center" nowrap="nowrap"><span class="rinpen"><span class="teihen"></span></span><hr noshade="noshade" size="1"><span class="shahen"></span></td><td>=<span class="cos"></span></td></tr></tbody></table></div>
		  <br>
		  <div><table cellpadding="2" cellspacing="0"><tbody><tr><td>tanθ=</td><td align="center" nowrap="nowrap"><span class="taihen"><span class="takasa"></span></span><hr noshade="noshade" size="1"><span class="rinpen"><span class="teihen"></span></span></td><td>=<span class="tan"></span></td></tr></tbody></table></div>
		  <div data-role="footer" align="center">
			<input type="button" value="HOME" data-icon="home" onclick="location.href='./index.html'">
			<input type="button" value="戻る" data-icon="back"  onclick="history.back();">
			<input type="button" onclick="location.href='#page2'" data-icon="arrow-r" value="θの範囲について">
		  </div>
	  </div>
	</div>
	<div data-role="page" id="page2">
	  <div data-role="header">
		<h1>θの範囲について</h1>
	  </div>
	  <div data-role="content">
		<p>　ここまでで示した「直角三角形の辺の比」という定義では、角度θは$0<\theta<{\pi\over 2}$でなくてはいけない。ではθが${\pi\over2}$を超えた（ただしまだπは超えてない）場合は$\sin\theta,\cos\theta$は値がないのかというと、ここで<span class="fukidasi">定義を拡張する</span>ことでθが${\pi\over2}$を超えても大丈夫なようにする。</p>

		<p>　具体的には、下の図のように逆側に三角形を作り、その「<span class="taihen">対辺の長さ</span>」と「<span class="rinpen">-(隣辺の長さ)</span>」（マイナス符号に注意）をそれぞれ${\sin\theta}$と$\cos\theta$の定義とする。</p>
		<div class="setsumei">　前のページで遊んでみた人は、θという角度が0からπ/2という範囲以外にもなることに気づいただろうか？？？発見できる人には自分で発見して欲しいと思って、あえて説明していなかったが、点は元々の三角形の裏側まで動かすことができる。</div>
		<p><img src="chokkakugoe.png" class="floatnone">のように<big>θが直角より大きく</big>なり「<span class="taihen">対辺の長さ</span>が負」であったり、<img src="funokakudo.png" class="floatnone">のように<big>θが負</big>になり「<span class="rinpen">底辺</span>が負」になる場合であったりする位置にも移動できる。</p>
		<p></p>
		<p>  　前のページで気づいてなかった、という人は、下の図でやってみよう<small>（下の図は前のページのものと機能は同じである）</small>。 </p>
		<div align="center"><canvas id="canvas1" width=200 height=200 style="-ms-touch-action:none;"></canvas></div>
		<div>	
		  <div align="center" class="teihen" id="teihen"></div>
		  <br>
		  <div align="center" class="takasa" id="takasa"></div>
		  <br>
		  <div align="center" class="shahen" id="shahen"></div>
		  <br><div align="center" class="theta"></div>
		</div>
		<br>
		<div><table cellpadding="2" cellspacing="0"><tbody><tr><td>sinθ=</td><td align="center" nowrap="nowrap"><span class="takasa"></span><hr noshade="noshade" size="1"><span class="shahen"></span></td><td>=<span class="sin"></span></td></tr></tbody></table></div>
		<br>
		<div><table cellpadding="2" cellspacing="0"><tbody><tr><td>cosθ=</td><td align="center" nowrap="nowrap"><span class="rinpen"><span class="teihen"></span></span><hr noshade="noshade" size="1"><span class="shahen"></span></td><td>=<span class="cos"></span></td></tr></tbody></table></div>
		<br>
		<div><table cellpadding="2" cellspacing="0"><tbody><tr><td>tanθ=</td><td align="center" nowrap="nowrap"><span class="takasa"></span><hr noshade="noshade" size="1"><span class="rinpen"><span class="teihen"></span></span></td><td>=<span class="tan"></span></td></tr></tbody></table></div>

		<p>　ここでθが${\pi\over2}$を超えた時、底辺が伸びる方向はさっきまでとは逆向きになった（図ではそれを表現するために$\cos\theta$を左右反転した文字で書いた）ので、負の値とすることにして、${\cos\theta}$を「$-(隣辺の長さ)$」と決めた。</p>
		<p>　このように考えたのだから、θが最初考えていた領域をちょうど超える場所である$\theta={\pi\over 2}$については、${\sin{\pi\over2}}=1,{\cos{\pi\over2}}=0$とするのが適当である。「$\theta={\pi\over 2}$では三角形はできないではないか！」と言いたくなる人もいるかもしれないが、<span class="fukidasi">定義を拡張する</span>というのはそういうことである<span class="footnote">そしてこの拡張が、ちゃんと役に立つ場合、それが一般に使われるようになる。どう役に立つのかについては、以下を読んで欲しい。</span>。
	  </div>
	  <div data-role="footer" align="center">
		  <input type="button" onclick="location.href='#page1'" data-icon="arrow-l" value="三角形の辺の比による定義">
		  <input type="button" value="HOME" data-icon="home" onclick="location.href='./index.html'">
		  <input type="button" value="戻る" data-icon="back"  onclick="history.back();">
		  <input type="button" onclick="location.href='#page3'" data-icon="arrow-r" value="斜辺を1に固定した直角三角形">
	  </div>
	</div>
	</div>
	<div data-role="page" id="page3">
	  <div data-role="header">
		<h1>斜辺を1に固定した直角三角形</h1>
	  </div>
	  <div data-role="content">
		<p>　下の図は<span class="ki">斜辺</span>を1で一定にして角度θを変化させていったときの直角三角形の<span class="taihen">対辺</span>と<span class="rinpen">隣辺</span>の変化の様子である。<span class="ki">斜辺</span>を1とすると<span class="taihen">対辺の長さ</span>は$\sin\theta$、<span class="rinpen">隣辺の長さ</span>は$\cos\theta$であるが、角度が大きくなるに従って$\sin\theta$は大きくなり、$\cos\theta$は小さくなる（こうなるのは、$0<\theta<{\pi\over 2}$の範囲に限って考えているからであり、${\pi\over2}$を超えると事情が変わってくる）。</p>

		<p>　ここでも<span class="fukidasi">直角以外の角を結ぶ辺</span>が長さ1となっていて、<span class="fukidasi">角度θの角と直角を結ぶ辺</span>長さ$\cos \theta$、それ以外の辺が長さ$\sin\theta$となっている。</p>
		<div align="center"><canvas id="canvas3" width=200 height=200 style="-ms-touch-action:none;"></canvas></div>
		<div align="center"><span class="theta"></span>,　　<span class="taihen">sinθ=<span class="sin"></span></span>,　　<span class="rinpen">cosθ=<span class="cos"></span></span></div>
		<div class="setsumei">　上の図もドラッグで直角三角形を移動・変形できるが、<span class="ki">斜辺</span>の長さは一定になっている。角度と<span class="rinpen">cosθ</span>と<span class="taihen">sinθ</span>の変化の様子を観察しよう。<br>
		  　sin,cosが正になったり負になったりするが、<img src="akadama.png" class="floatnone">から<img src="aodama.png" class="floatnone">に向かう方向が「上」「右」の時にsin,cosは正であり、「下」「左」の時にはsin,cosは負である。図ではそれを<img src="sintheta.png" class="floatnone">や<img src="costheta.png" class="floatnone">が鏡文字になることで表現している。</div>
		<img src="chokakusankakukeidandan4.png" class="floatright" width="20%">
		<p>　次に、隣辺を一定（1）にした場合に角度を変えると<span class="taihen">対辺の長さ</span>がどのように変わるかを示したのが右の図である。</p>
		<p><span class="ki">斜辺の長さ</span>は図に示していないが、$\sec\theta={1\over \cos\theta}$であり、θの変化に伴い変化する。</p>
		<p>　上の定義から、三角関数相互の関係を出してみよう。たとえば、</p>
		\begin{equation}
		\definecolor{rin}{RGB}{213,123,53}
		\definecolor{tai}{RGB}{187,63,133}
		\definecolor{sha}{RGB}{145,138,0}
		{{\sin\theta}\over{\cos \theta}}={{{\color{tai}対辺の長さ}\over{{\scriptstyle \color{sha}斜辺の長さ}}}\over {{\scriptstyle \color{rin}隣辺の長さ}\over {{\scriptstyle \color{sha}斜辺の長さ}}}}={{{ \color{tai}対辺の長さ}}\over {{ \color{rin}隣辺の長さ}}}=\tan\theta
		\end{equation}
		<p>である。同様に${\cos \theta\over \sin \theta}=\cot\theta$である<span class="footnote">この後θの範囲は最初に定義した$0<\theta<{\pi\over 2}$からどんどん広がっていくのだが、これらの式はθがどのような範囲でも成立する。</span>。</p>

		<p>　<span class="ki">斜辺の長さ</span>が1である三角形、<span class="rinpen">隣辺の長さ</span>が1である三角形、<span class="taihen">対辺の長さ</span>が1である三角形を書いてみると次の図のようになる（この図の三つの三角形は互いに相似である）。</p>

		<img src="sankakuhikoushiki.png" class="floatnone" width="80%">

		<p>　これらの図に、三平方の定理（ピタゴラスの定理）すなわち
		  $$
		  ({\color{rin}隣辺の長さ})^2+({\color{tai}対辺の長さ})^2=({\color{sha}斜辺の長さ})^2
		  $$
		  を適用すると、以下の式が導ける<span class="footnote">こういう式を「新しい公式だ！」と単に覚えようとするのではなく、三平方の定理という「おなじみの式」の１つの変形なのだ、という事実も含めて頭の中に（図と関連付けて）整理しておこう。バラバラに覚えた「公式」はすぐに忘れてしまうが、相互につながりを持って認識された知識は、なかなか忘れない。</span>。</p>

		<p align="center">三角比と三平方の定理の式</p>
		$$
{\color{rin}\cos^2{\theta}}+{\color{tai}\sin ^2{\theta}}={\color{sha}1},~~
{\color{rin}1}+{\color{tai}\tan ^2{\theta}}={\color{sha}{1\over \cos^2{\theta}}}={\color{sha}\sec^2{\theta}},~~
 {\color{rin}\cot^2{\theta}} +{\color{tai}1} ={\color{sha}{1\over\sin ^2{\theta}} }={\color{sha}{\rm cosec}^2\,{\theta}}
		$$
		<div class="setsumei">$({\sin\theta})^2$は$\sin^2\theta$と書くのが昔からの慣習である（$\cos$や$\tan$も同様）。$\sin \theta^2$と書いてしまうと、「$\theta^2$という角度の$\sin$」と解釈される。慣れないうちは戸惑うかもしれないが、省略記法というのは「そういうものだ」と思って慣れるしかない。</div>
	  </div>
	  <div data-role="footer" align="center">
		  <input type="button" onclick="location.href='#page2'" data-icon="arrow-l" value="θの範囲について">
		<input type="button" value="HOME" data-icon="home" onclick="location.href='./index.html'">
		<input type="button" value="戻る" data-icon="back"  onclick="history.back();">
		  <input type="button" onclick="location.href='#page4_0'" data-icon="arrow-r" value="任意の角度のsin">
	  </div>
	</div>
	<div data-role="page" id="page4_0">
	  <div data-role="header">
		<h1>任意の角度のsin</h1>
	  </div>
	  <div data-role="content">
		<p>　次に、任意の角度でのsinとcosを以下の図のように定義しよう。ここまでで動かしてみてθという角度の意味は<img src="akadama.png" class="floatnone">から<img src="aodama.png" class="floatnone">に向かう方向を表すものであることがわかったと思うので、ここからは<img src="akadama.png" class="floatnone">を固定して、斜辺にあたる角度の変わる部分の長さを1に固定して考える。</p>
		<p>　まず、sinθの方だけを考えることにしよう。</p>
		<div align="center"><canvas id="canvas4_0" width=200 height=200 style="-ms-touch-action:none;"></canvas></div>
		<div class="theta"></div>
		<div class="setsumei">
		  　↑の棒の角度はドラッグによって変えることができる。<br>
		  <br>　この図の<img src="tanien1.png" class="floatnone">は半径１の円（単位円）を描いたもので、中心から円周の一点に向かっている棒<img src="bou.png" class="floatnone">の角度に応じて、<span class="taihen">sinθ</span>の値が決まる。
		  
		  <img src="tanien2.png" class="floatnone">のように2πより大きい（何周も回る）角度にしたり、<br>
		  <img src="tanien3.png" class="floatnone">のように負の角度にしたりもできるので、いろいろ変えて状況を確認して欲しい。
		</div>
		<p>　以上で図に描いたように考えることでθが$0<\theta<{\pi\over 2}$でない時も$\sin \theta,\cos \theta$が意味のある量となる。具体的には、下の図のように座標原点に一端を置いた長さ1の棒（これは直角三角形の<span class="ki">斜辺</span>を1に固定したことに対応する）を<span class="aka">x</span>軸からどれだけの角度回したか、という変数としてθを定義して、棒のもう一端の<span class="aka">x</span>座標を$\cos \theta$、<span class="ao">y</span>座標を$\sin\theta$と定義するのである。</p>

		<img src="defsincos.png" width="80%" class="floatnone">
		<img src="defsincos2.png" width="30%">
		<p>　こうすればθは$2\pi$も超えて$\infty$まで任意の角度を取ることができる。θが$2\pi$を超えた時は、上右の図のように、棒が何周も回ったと考えればよいのである。また、右の図に描いたように、「負の角度」に対しても定義できる。</p>
		<p>　こうして、任意の実数に対して$\sin \theta,\cos \theta$を定義することができた。グラフで表現すると次のようになる。</p>
		<img src="graphsincos.png" width="80%" class="floatnone">
		<p>　三角関数のうち$\sin\theta,\cos \theta$以外の他の４つ（$\tan\theta,\sec\theta,{\rm cosec}~\theta,\cot\theta$）に関しては「定義できない値」がある。たとえば$\tan\theta={\sin \theta\over \cos \theta}$は$\cos \theta=0$となる場所では定義できない。</p>
	  </div>
	  <div data-role="footer" align="center">
		  <input type="button" onclick="location.href='#page3'" data-icon="arrow-l" value="斜辺を1に固定した直角三角形">
		<input type="button" value="HOME" data-icon="home" onclick="location.href='./index.html'">
		<input type="button" value="戻る" data-icon="back"  onclick="history.back();">
		  <input type="button" onclick="location.href='#page4'" data-icon="arrow-r" value="任意の角度のsin,cos">
	  </div>
	</div>
	<div data-role="page" id="page4">
	  <div data-role="header">
		<h1>任意の角度のsin,cos</h1>
	  </div>
	  <div data-role="content">
		<p>　次に、sinθとcosθを同時に表示してみよう。さっきはθは任意の角度にしておいたが、今度は-πからπまで（-180度から180度まで）にしておく。</p>
		<div align="center"><canvas id="canvas4" width=200 height=200 style="-ms-touch-action:none;"></canvas></div>
	  </div>
	  <div data-role="footer" align="center">
		  <input type="button" onclick="location.href='#page4_0'" data-icon="arrow-l" value="任意の角度のsin">
		  <input type="button" value="HOME" data-icon="home" onclick="location.href='./index.html'">
		  <input type="button" value="戻る" data-icon="back"  onclick="history.back();">
		  <input type="button" onclick="location.href='#page5'" data-icon="arrow-r" value="三角関数の間の公式">
	  </div>
	</div>
	<div data-role="page" id="page5">
	  <div data-role="header">
		<h1>三角関数の間の公式</h1>
	  </div>
	  <div data-role="content">
		<p>　三角関数の「公式」として、</p>
		<p>sin(θ+π)=-sinθ</p>
		<p>cos(θ+π)=-cosθ</p>
		<p>というものがある。この式がなぜ成立するか、は下の図でしばらく遊んでみればわかるのではないかと思う。</p>
		<div align="center"><canvas id="canvas5" width=200 height=200 style="-ms-touch-action:none;"></canvas></div>
		<p>　図の<img src="tukinuke.png">の部分の薄い色になっている<img src="pluspi.png">の方が、θよりπラジアン（180度）大きい角度の場合の「長さ1の棒」になっている。sin,cosがπ足されることでどう変化するかを、図から読み取っていけば、公式が作られる（この公式は式として覚えようとしなくても、意味を考えればすぐにわかる）。</p>
	  </div>
	  <div data-role="footer" align="center">
		  <input type="button" onclick="location.href='#page4'" data-icon="arrow-l" value="任意の角度のsin,cos">
		  <input type="button" value="HOME" data-icon="home" onclick="location.href='./index.html'">
		  <input type="button" value="戻る" data-icon="back"  onclick="history.back();">
		  <input type="button" onclick="location.href='#page6'" data-icon="arrow-r" value="三角関数の間の公式（続）">
	  </div>
	</div>
	<div data-role="page" id="page6">
	  <div data-role="header">
		<h1>三角関数の間の公式（続）</h1>
	  </div>
	  <div data-role="content">
		<p>　前ページ同様によくでてくる三角関数の公式として、</p>
		<p><table cellpadding="2" cellspacing="0"><tbody><tr><td>sin<big><big>(</big></big>θ+</td><td align="center" nowrap="nowrap">π<hr noshade="noshade" size="1">2</td><td><big><big>)</big></big>= cosθ</td></tr></tbody></table></p>
		<p><table cellpadding="2" cellspacing="0"><tbody><tr><td>cos<big><big>(</big></big>θ+</td><td align="center" nowrap="nowrap">π<hr noshade="noshade" size="1">2</td><td><big><big>)</big></big>= -sinθ</td></tr></tbody></table></p>
		<p>がある。これも下の図で遊びながら理解して欲しい。</p>
		<div align="center"><canvas id="canvas6" width=200 height=200 style="-ms-touch-action:none;"></canvas></div>
		<p>これが分かれば、</p>
		<p><table cellpadding="2" cellspacing="0"><tbody><tr><td>sin<big><big>(</big></big>θ-</td><td align="center" nowrap="nowrap">π<hr noshade="noshade" size="1">2</td><td><big><big>)</big></big>= -cosθ</td></tr></tbody></table></p>
		<p><table cellpadding="2" cellspacing="0"><tbody><tr><td>cos<big><big>(</big></big>θ-</td><td align="center" nowrap="nowrap">π<hr noshade="noshade" size="1">2</td><td><big><big>)</big></big>= sinθ</td></tr></tbody></table></p>
		<p>の方も理解できるだろう。</p>
		<p>　あと一つのよく使う三角関数である$\tan\theta$についても$\sin ,\cos $同様、長さ1の棒を使っての定義とグラフを書いておこう。$\tan\theta$は${対辺の長さ\over \scriptstyle 隣辺の長さ}$と定義したから、「<span class="rinpen">隣辺の長さ</span>を1にした時の<span class="ao">対辺の長さ</span>」と考えればよい。よって下の図左側に描いたように、<span class="rinpen">隣辺</span>を1にして、（つまり、<span class="ki">棒の長さ</span>をそれに応じて変えつつ）角度θを変化させ、その時の三角形の対辺の長さを$\tan\theta$とする。ただしこの手順では「棒」が左を向いた時には（図で点線で表現したように）斜辺を逆に伸ばして三角形を作る（こうすることでちゃんと$\tan\theta={\sin \theta\over \cos\theta}$が成立するようになる）。</p>
		<img src="graphtan.png" width="75%" class="floatnone">

		<p>　上でも述べたように、$\tan\theta$は$\theta={\pi\over 2}+n\pi$（これは$\cos\theta=0$となる場所）では定義できない。同様に${\rm cosec}~\theta={1\over \sin\theta}$は$\theta=n\pi$では定義できず、$\sec\theta={1\over \cos\theta}$は${\pi\over 2}+n\pi$では定義できない。</p>

		<img src="sincostanseccoseccot.png" width="80%"  class="floatnone">

		<p>　これらの定義から、nを整数として「θに$2\pi$を何回足しても、すなわち<span class="ki">棒</span>を一周あるいは複数回だけ回しても、$\sin \theta$や$\cos \theta$の値は変わらない」ということ
		  \begin{equation}
		  \sin (\theta+2n\pi)=\sin \theta,~~~
		  \cos (\theta+2n\pi)=\cos \theta
		  \end{equation}
		</p>
		<p>および、「θにπを何回足しても、すなわち<span class="ki">棒</span>を半周もしくはその整数倍回だけ回しても、$\tan\theta$の値は変わらない」ということが結論できる。
		  \begin{equation}
		  \tan (\theta+n\pi)=\tan \theta
		  \end{equation}
		</p>
	  </div>
	  <div data-role="footer" align="center">
		  <input type="button" onclick="location.href='#page5'" data-icon="arrow-l" value="三角関数の間の公式">
		  <input type="button" value="HOME" data-icon="home" onclick="location.href='./index.html'">
		  <input type="button" value="戻る" data-icon="back"  onclick="history.back();">
	  </div>
	</div>
  </body>
</html>
